name: Production Promotion

on:
  workflow_dispatch:
    inputs:
      repo_tags:
        description: >-
          Comma-separated repo:tag pairs, e.g.
          chrono-devops:v1.3.0,chrono-api:v2.5.0,chrono-app:v3.1.0
        required: true
        type: string

concurrency:
  group: production-promote
  cancel-in-progress: false

jobs:
  validate:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.parse.outputs.matrix }}
    steps:
      - name: Parse and validate repo_tags
        id: parse
        env:
          REPO_TAGS_INPUT: ${{ inputs.repo_tags }}
        run: |
          ALLOWED_REPOS="chrono-devops chrono-api chrono-pipeline-v2 chrono-app chrono-filter-ai-api"
          SEMVER_REGEX="^v[0-9]+\.[0-9]+\.[0-9]+$"

          IFS=',' read -ra PAIRS <<< "$REPO_TAGS_INPUT"

          if [ ${#PAIRS[@]} -eq 0 ]; then
            echo "::error::No repo:tag pairs provided"
            exit 1
          fi

          JSON="["
          FIRST=true

          for pair in "${PAIRS[@]}"; do
            pair="$(echo "$pair" | xargs)"  # trim whitespace

            repo="${pair%%:*}"
            tag="${pair#*:}"

            if [ "$repo" = "$pair" ] || [ -z "$tag" ]; then
              echo "::error::Invalid format '$pair' — expected repo:tag"
              exit 1
            fi

            # Validate repo name
            if ! echo "$ALLOWED_REPOS" | grep -qw "$repo"; then
              echo "::error::Unknown repo '$repo'. Allowed: $ALLOWED_REPOS"
              exit 1
            fi

            # Validate tag is stable semver (no pre-release suffix)
            if ! [[ "$tag" =~ $SEMVER_REGEX ]]; then
              echo "::error::Tag '$tag' for repo '$repo' is not stable semver (expected vX.Y.Z with no suffix)"
              exit 1
            fi

            if [ "$FIRST" = true ]; then
              FIRST=false
            else
              JSON+=","
            fi
            JSON+="{\"repo\":\"$repo\",\"tag\":\"$tag\"}"

            echo "Validated: $repo @ $tag"
          done

          JSON+="]"

          echo "Parsed matrix: $JSON"
          echo "matrix=$JSON" >> "$GITHUB_OUTPUT"

  approve:
    needs: validate
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Confirm approval
        run: echo "Production deployment approved"

  push-tags:
    needs: [validate, approve]
    runs-on: ubuntu-latest
    environment: deploy-bot
    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@d72941d797fd3113feb6b93fd0dec494b13a2547  # v1.12.0
        with:
          app-id: ${{ secrets.DEPLOY_APP_ID }}
          private-key: ${{ secrets.DEPLOY_APP_PRIVATE_KEY }}
          owner: Quoyi-ChronoTracer
          repositories: chrono-devops,chrono-api,chrono-pipeline-v2,chrono-app,chrono-filter-ai-api

      - name: Mask token
        run: echo "::add-mask::${{ steps.app-token.outputs.token }}"

      - name: Push tags to component repos
        env:
          MATRIX: ${{ needs.validate.outputs.matrix }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          git config --global user.name "ChronoTracer Deploy Bot"
          git config --global user.email "ci@chronotracer.com"
          git config --global url."https://x-access-token:${GH_TOKEN}@github.com/".insteadOf "https://github.com/"

          COUNT=$(echo "$MATRIX" | jq length)
          echo "Pushing tags for $COUNT repo(s)..."
          echo ""

          FAILED=()

          for i in $(seq 0 $(( COUNT - 1 ))); do
            REPO=$(echo "$MATRIX" | jq -r ".[$i].repo")
            TAG=$(echo "$MATRIX" | jq -r ".[$i].tag")

            echo "----------------------------------------"
            echo "[$REPO] Cloning and tagging $TAG"
            echo "----------------------------------------"

            git clone "https://github.com/Quoyi-ChronoTracer/${REPO}.git" "$REPO"
            cd "$REPO"

            # Verify an RC tag exists for this version and resolve its commit
            RC_EXISTS=$(git tag -l "${TAG}-rc.*" | sort -V | tail -1)
            if [ -z "$RC_EXISTS" ]; then
              echo "::error::No RC tag found for ${TAG} in ${REPO}. Cannot promote without staging first."
              FAILED+=("$REPO")
              cd ..
              continue
            fi

            RC_COMMIT=$(git rev-list -n 1 "$RC_EXISTS")
            echo "[$REPO] Promoting commit $RC_COMMIT from $RC_EXISTS"

            git tag -a "$TAG" "$RC_COMMIT" -m "Release $TAG — promoted from $RC_EXISTS"

            if ! git push origin "$TAG" 2>&1; then
              echo "::error::Failed to push $TAG to $REPO"
              FAILED+=("$REPO")
              cd ..
              continue
            fi

            echo "[$REPO] Successfully pushed tag $TAG"
            echo ""

            cd ..
          done

          echo "========================================"
          echo "Production promotion complete."
          echo "Tagged repos:"
          for i in $(seq 0 $(( COUNT - 1 ))); do
            REPO=$(echo "$MATRIX" | jq -r ".[$i].repo")
            TAG=$(echo "$MATRIX" | jq -r ".[$i].tag")
            echo "  - $REPO @ $TAG"
          done
          echo "========================================"

          if [ ${#FAILED[@]} -gt 0 ]; then
            echo ""
            echo "::error::Failed repos: ${FAILED[*]}"
            exit 1
          fi

  trigger-circleci:
    needs: [validate, push-tags]
    runs-on: ubuntu-latest
    environment: deploy-bot
    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@d72941d797fd3113feb6b93fd0dec494b13a2547  # v1.12.0
        with:
          app-id: ${{ secrets.DEPLOY_APP_ID }}
          private-key: ${{ secrets.DEPLOY_APP_PRIVATE_KEY }}
          owner: Quoyi-ChronoTracer
          repositories: chrono-devops,chrono-api,chrono-pipeline-v2,chrono-app,chrono-filter-ai-api

      - name: Mask token
        run: echo "::add-mask::${{ steps.app-token.outputs.token }}"

      - name: Trigger CircleCI pipelines in dependency order
        env:
          MATRIX: ${{ needs.validate.outputs.matrix }}
          CIRCLECI_TOKEN: ${{ secrets.CIRCLECI_API_TOKEN }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          DEPLOY_ENV: production
        run: |
          REPOS_IN_PLAN=$(echo "$MATRIX" | jq -r '.[].repo')

          has_repo() {
            echo "$REPOS_IN_PLAN" | grep -qx "$1"
          }

          # --- Dependency tiers ---
          # Tier 0: chrono-devops (infra)
          # Tier 1: chrono-api (backend)
          # Tier 2: chrono-pipeline-v2, chrono-app, chrono-filter-ai-api (edge)
          TIER_0=("chrono-devops")
          TIER_1=("chrono-api")
          TIER_2=("chrono-pipeline-v2" "chrono-app" "chrono-filter-ai-api")

          # --- Helper: trigger a repo and create GitHub Deployment ---
          trigger_repo() {
            local repo="$1"
            local tag="$2"

            echo "[TRIGGER] $repo @ $tag"

            HTTP_CODE=$(curl -s -o /tmp/cci_${repo}.json -w "%{http_code}" \
              -X POST "https://circleci.com/api/v2/project/gh/Quoyi-ChronoTracer/${repo}/pipeline" \
              -H "Circle-Token: ${CIRCLECI_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "{\"tag\": \"${tag}\", \"parameters\": {\"trigger_deploy\": true}}")

            if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
              echo "::error::Failed to trigger CircleCI for $repo (HTTP $HTTP_CODE)"
              cat /tmp/cci_${repo}.json
              return 1
            fi

            local pipeline_id=$(jq -r '.id' /tmp/cci_${repo}.json)
            local pipeline_num=$(jq -r '.number' /tmp/cci_${repo}.json)
            echo "[OK] $repo — CircleCI pipeline $pipeline_id triggered"

            # Create GitHub Deployment
            local deploy_response=$(curl -s -X POST \
              "https://api.github.com/repos/Quoyi-ChronoTracer/${repo}/deployments" \
              -H "Authorization: token ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -d "$(jq -n --arg ref "$tag" --arg env "$DEPLOY_ENV" '{
                ref: $ref,
                environment: $env,
                auto_merge: false,
                required_contexts: [],
                description: ("Deployment via " + $env + " promote workflow")
              }')")

            local deployment_id=$(echo "$deploy_response" | jq -r '.id')
            echo "[DEPLOY] $repo — GitHub deployment $deployment_id created"

            # Set initial status
            curl -s -X POST \
              "https://api.github.com/repos/Quoyi-ChronoTracer/${repo}/deployments/${deployment_id}/statuses" \
              -H "Authorization: token ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -d "$(jq -n --arg url "https://app.circleci.com/pipelines/github/Quoyi-ChronoTracer/${repo}/${pipeline_num}" '{
                state: "in_progress",
                target_url: $url,
                description: "CircleCI pipeline running"
              }')" > /dev/null

            # Store IDs for polling
            echo "${pipeline_id}:${deployment_id}:${pipeline_num}" > /tmp/tier_${repo}.txt
          }

          # --- Helper: poll a tier until all pipelines finish (30 min max) ---
          poll_tier() {
            local tier_name="$1"
            shift
            local repos=("$@")

            if [ ${#repos[@]} -eq 0 ]; then
              return 0
            fi

            echo ""
            echo "Polling $tier_name (${repos[*]})..."

            local max_attempts=60
            local sleep_seconds=30
            declare -A finished=()

            for attempt in $(seq 1 $max_attempts); do
              local all_done=true

              for repo in "${repos[@]}"; do
                if [ -n "${finished[$repo]:-}" ]; then
                  continue
                fi

                IFS=':' read -r pid did pnum < /tmp/tier_${repo}.txt
                local target_url="https://app.circleci.com/pipelines/github/Quoyi-ChronoTracer/${repo}/${pnum}"

                local wf_response=$(curl -s \
                  "https://circleci.com/api/v2/pipeline/${pid}/workflow" \
                  -H "Circle-Token: ${CIRCLECI_TOKEN}")

                local status=$(echo "$wf_response" | jq -r '.items[0].status // "pending"')

                case "$status" in
                  success)
                    echo "[DONE] $repo — success"
                    curl -s -X POST \
                      "https://api.github.com/repos/Quoyi-ChronoTracer/${repo}/deployments/${did}/statuses" \
                      -H "Authorization: token ${GH_TOKEN}" \
                      -H "Accept: application/vnd.github+json" \
                      -d "$(jq -n --arg url "$target_url" '{
                        state: "success",
                        target_url: $url,
                        description: "Deployment succeeded"
                      }')" > /dev/null
                    finished[$repo]="success"
                    ;;
                  failed|error|canceled)
                    echo "[FAIL] $repo — $status"
                    curl -s -X POST \
                      "https://api.github.com/repos/Quoyi-ChronoTracer/${repo}/deployments/${did}/statuses" \
                      -H "Authorization: token ${GH_TOKEN}" \
                      -H "Accept: application/vnd.github+json" \
                      -d "$(jq -n --arg url "$target_url" --arg status "$status" '{
                        state: "failure",
                        target_url: $url,
                        description: ("Deployment " + $status)
                      }')" > /dev/null
                    finished[$repo]="$status"
                    ;;
                  *)
                    all_done=false
                    ;;
                esac
              done

              if [ "$all_done" = true ]; then
                break
              fi

              if [ "$attempt" -lt "$max_attempts" ]; then
                echo "[POLL $attempt/$max_attempts] Waiting ${sleep_seconds}s..."
                sleep $sleep_seconds
              fi
            done

            # Check results
            local tier_ok=true
            for repo in "${repos[@]}"; do
              local result="${finished[$repo]:-}"
              if [ -z "$result" ]; then
                echo "[TIMEOUT] $repo — still running after 30m"
                IFS=':' read -r pid did pnum < /tmp/tier_${repo}.txt
                curl -s -X POST \
                  "https://api.github.com/repos/Quoyi-ChronoTracer/${repo}/deployments/${did}/statuses" \
                  -H "Authorization: token ${GH_TOKEN}" \
                  -H "Accept: application/vnd.github+json" \
                  -d "$(jq -n --arg url "https://app.circleci.com/pipelines/github/Quoyi-ChronoTracer/${repo}/${pnum}" '{
                    state: "in_progress",
                    target_url: $url,
                    description: "Polling timed out — check CircleCI for final status"
                  }')" > /dev/null
                tier_ok=false
              elif [ "$result" != "success" ]; then
                tier_ok=false
              fi
            done

            if [ "$tier_ok" = true ]; then
              return 0
            else
              return 1
            fi
          }

          # --- Main: process tiers in dependency order ---
          ALL_TRIGGERED=()

          for tier_idx in 0 1 2; do
            case $tier_idx in
              0) tier_repos=("${TIER_0[@]}"); tier_label="Tier 0 (infra)" ;;
              1) tier_repos=("${TIER_1[@]}"); tier_label="Tier 1 (backend)" ;;
              2) tier_repos=("${TIER_2[@]}"); tier_label="Tier 2 (edge)" ;;
            esac

            # Filter to repos in the deploy plan
            tier_active=()
            for repo in "${tier_repos[@]}"; do
              if has_repo "$repo"; then
                tier_active+=("$repo")
              fi
            done

            if [ ${#tier_active[@]} -eq 0 ]; then
              echo ""
              echo "[SKIP] $tier_label — no repos in deploy plan"
              continue
            fi

            echo ""
            echo "========================================"
            echo "$tier_label: ${tier_active[*]}"
            echo "========================================"

            # Trigger all repos in this tier
            for repo in "${tier_active[@]}"; do
              TAG=$(echo "$MATRIX" | jq -r --arg r "$repo" '.[] | select(.repo == $r) | .tag')
              trigger_repo "$repo" "$TAG" || exit 1
              ALL_TRIGGERED+=("$repo")
            done

            # Poll until tier completes
            if ! poll_tier "$tier_label" "${tier_active[@]}"; then
              echo ""
              echo "::error::$tier_label failed — aborting downstream tiers"
              echo ""
              echo "========================================"
              echo "Deployment summary:"
              for repo in "${ALL_TRIGGERED[@]}"; do
                if [ -f /tmp/tier_${repo}.txt ]; then
                  echo "  - $repo: check CircleCI"
                fi
              done
              echo "========================================"
              exit 1
            fi
          done

          echo ""
          echo "========================================"
          echo "All tiers completed successfully."
          echo "Deployed repos:"
          for repo in "${ALL_TRIGGERED[@]}"; do
            echo "  - $repo"
          done
          echo "========================================"
