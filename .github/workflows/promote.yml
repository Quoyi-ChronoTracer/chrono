name: Production Promotion

on:
  workflow_dispatch:
    inputs:
      repo_tags:
        description: >-
          Comma-separated repo:tag pairs, e.g.
          chrono-devops:v1.3.0,chrono-api:v2.5.0,chrono-app:v3.1.0
        required: true
        type: string

concurrency:
  group: production-promote
  cancel-in-progress: false

jobs:
  validate:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.parse.outputs.matrix }}
    steps:
      - name: Parse and validate repo_tags
        id: parse
        env:
          REPO_TAGS_INPUT: ${{ inputs.repo_tags }}
        run: |
          ALLOWED_REPOS="chrono-devops chrono-api chrono-pipeline-v2 chrono-app chrono-filter-ai-api"
          SEMVER_REGEX="^v[0-9]+\.[0-9]+\.[0-9]+$"

          IFS=',' read -ra PAIRS <<< "$REPO_TAGS_INPUT"

          if [ ${#PAIRS[@]} -eq 0 ]; then
            echo "::error::No repo:tag pairs provided"
            exit 1
          fi

          JSON="["
          FIRST=true

          for pair in "${PAIRS[@]}"; do
            pair="$(echo "$pair" | xargs)"  # trim whitespace

            repo="${pair%%:*}"
            tag="${pair#*:}"

            if [ "$repo" = "$pair" ] || [ -z "$tag" ]; then
              echo "::error::Invalid format '$pair' — expected repo:tag"
              exit 1
            fi

            # Validate repo name
            if ! echo "$ALLOWED_REPOS" | grep -qw "$repo"; then
              echo "::error::Unknown repo '$repo'. Allowed: $ALLOWED_REPOS"
              exit 1
            fi

            # Validate tag is stable semver (no pre-release suffix)
            if ! [[ "$tag" =~ $SEMVER_REGEX ]]; then
              echo "::error::Tag '$tag' for repo '$repo' is not stable semver (expected vX.Y.Z with no suffix)"
              exit 1
            fi

            if [ "$FIRST" = true ]; then
              FIRST=false
            else
              JSON+=","
            fi
            JSON+="{\"repo\":\"$repo\",\"tag\":\"$tag\"}"

            echo "Validated: $repo @ $tag"
          done

          JSON+="]"

          echo "Parsed matrix: $JSON"
          echo "matrix=$JSON" >> "$GITHUB_OUTPUT"

  approve:
    needs: validate
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Confirm approval
        run: echo "Production deployment approved"

  push-tags:
    needs: [validate, approve]
    runs-on: ubuntu-latest
    environment: deploy-bot
    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@d72941d797fd3113feb6b93fd0dec494b13a2547  # v1.12.0
        with:
          app-id: ${{ secrets.DEPLOY_APP_ID }}
          private-key: ${{ secrets.DEPLOY_APP_PRIVATE_KEY }}
          owner: Quoyi-ChronoTracer
          repositories: chrono-devops,chrono-api,chrono-pipeline-v2,chrono-app,chrono-filter-ai-api

      - name: Mask token
        run: echo "::add-mask::${{ steps.app-token.outputs.token }}"

      - name: Push tags to component repos
        env:
          MATRIX: ${{ needs.validate.outputs.matrix }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          git config --global user.name "ChronoTracer Deploy Bot"
          git config --global user.email "ci@chronotracer.com"
          git config --global url."https://x-access-token:${GH_TOKEN}@github.com/".insteadOf "https://github.com/"

          COUNT=$(echo "$MATRIX" | jq length)
          echo "Pushing tags for $COUNT repo(s)..."
          echo ""

          FAILED=()

          for i in $(seq 0 $(( COUNT - 1 ))); do
            REPO=$(echo "$MATRIX" | jq -r ".[$i].repo")
            TAG=$(echo "$MATRIX" | jq -r ".[$i].tag")

            echo "----------------------------------------"
            echo "[$REPO] Cloning and tagging $TAG"
            echo "----------------------------------------"

            git clone "https://github.com/Quoyi-ChronoTracer/${REPO}.git" "$REPO"
            cd "$REPO"

            # Verify an RC tag exists for this version and resolve its commit
            RC_EXISTS=$(git tag -l "${TAG}-rc.*" | sort -V | tail -1)
            if [ -z "$RC_EXISTS" ]; then
              echo "::error::No RC tag found for ${TAG} in ${REPO}. Cannot promote without staging first."
              FAILED+=("$REPO")
              cd ..
              continue
            fi

            RC_COMMIT=$(git rev-list -n 1 "$RC_EXISTS")
            echo "[$REPO] Promoting commit $RC_COMMIT from $RC_EXISTS"

            git tag -a "$TAG" "$RC_COMMIT" -m "Release $TAG — promoted from $RC_EXISTS"

            if ! git push origin "$TAG" 2>&1; then
              echo "::error::Failed to push $TAG to $REPO"
              FAILED+=("$REPO")
              cd ..
              continue
            fi

            echo "[$REPO] Successfully pushed tag $TAG"
            echo ""

            cd ..
          done

          echo "========================================"
          echo "Production promotion complete."
          echo "Tagged repos:"
          for i in $(seq 0 $(( COUNT - 1 ))); do
            REPO=$(echo "$MATRIX" | jq -r ".[$i].repo")
            TAG=$(echo "$MATRIX" | jq -r ".[$i].tag")
            echo "  - $REPO @ $TAG"
          done
          echo "========================================"

          if [ ${#FAILED[@]} -gt 0 ]; then
            echo ""
            echo "::error::Failed repos: ${FAILED[*]}"
            exit 1
          fi

  trigger-circleci:
    needs: [validate, push-tags]
    runs-on: ubuntu-latest
    environment: deploy-bot
    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@d72941d797fd3113feb6b93fd0dec494b13a2547  # v1.12.0
        with:
          app-id: ${{ secrets.DEPLOY_APP_ID }}
          private-key: ${{ secrets.DEPLOY_APP_PRIVATE_KEY }}
          owner: Quoyi-ChronoTracer
          repositories: chrono-devops,chrono-api,chrono-pipeline-v2,chrono-app,chrono-filter-ai-api

      - name: Mask token
        run: echo "::add-mask::${{ steps.app-token.outputs.token }}"

      - name: Trigger CircleCI and create GitHub Deployments
        env:
          MATRIX: ${{ needs.validate.outputs.matrix }}
          CIRCLECI_TOKEN: ${{ secrets.CIRCLECI_API_TOKEN }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          REPOS_IN_PLAN=$(echo "$MATRIX" | jq -r '.[].repo')

          has_repo() {
            echo "$REPOS_IN_PLAN" | grep -qx "$1"
          }

          # Gated repos need a CircleCI API call with trigger_deploy: true.
          # Ungated repos (chrono-devops, chrono-pipeline-v2) deploy via tag push alone.
          GATED_REPOS=("chrono-api" "chrono-app" "chrono-filter-ai-api")

          # Collect pipeline/deployment IDs for polling
          declare -a POLL_REPOS=()
          declare -a POLL_PIPELINE_IDS=()
          declare -a POLL_DEPLOYMENT_IDS=()

          for REPO in "${GATED_REPOS[@]}"; do
            if ! has_repo "$REPO"; then
              echo "[SKIP] $REPO — not in deploy plan"
              continue
            fi

            TAG=$(echo "$MATRIX" | jq -r --arg r "$REPO" '.[] | select(.repo == $r) | .tag')
            echo "[TRIGGER] $REPO @ $TAG"

            # Trigger CircleCI pipeline
            HTTP_CODE=$(curl -s -o /tmp/cci_${REPO}.json -w "%{http_code}" \
              -X POST "https://circleci.com/api/v2/project/gh/Quoyi-ChronoTracer/${REPO}/pipeline" \
              -H "Circle-Token: ${CIRCLECI_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "{\"tag\": \"${TAG}\", \"parameters\": {\"trigger_deploy\": true}}")

            if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
              echo "::error::Failed to trigger CircleCI for $REPO (HTTP $HTTP_CODE)"
              cat /tmp/cci_${REPO}.json
              exit 1
            fi

            PIPELINE_ID=$(jq -r '.id' /tmp/cci_${REPO}.json)
            PIPELINE_NUM=$(jq -r '.number' /tmp/cci_${REPO}.json)
            echo "[OK] $REPO — CircleCI pipeline $PIPELINE_ID triggered"

            # Create GitHub Deployment
            DEPLOY_RESPONSE=$(curl -s -X POST \
              "https://api.github.com/repos/Quoyi-ChronoTracer/${REPO}/deployments" \
              -H "Authorization: token ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -d "$(jq -n --arg ref "$TAG" --arg env "production" '{
                ref: $ref,
                environment: $env,
                auto_merge: false,
                required_contexts: [],
                description: "Production deployment via promote workflow"
              }')")

            DEPLOYMENT_ID=$(echo "$DEPLOY_RESPONSE" | jq -r '.id')
            echo "[DEPLOY] $REPO — GitHub deployment $DEPLOYMENT_ID created"

            # Set initial status to in_progress
            curl -s -X POST \
              "https://api.github.com/repos/Quoyi-ChronoTracer/${REPO}/deployments/${DEPLOYMENT_ID}/statuses" \
              -H "Authorization: token ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -d "$(jq -n --arg url "https://app.circleci.com/pipelines/github/Quoyi-ChronoTracer/${REPO}/${PIPELINE_NUM}" '{
                state: "in_progress",
                target_url: $url,
                description: "CircleCI pipeline running"
              }')" > /dev/null

            POLL_REPOS+=("$REPO")
            POLL_PIPELINE_IDS+=("$PIPELINE_ID")
            POLL_DEPLOYMENT_IDS+=("$DEPLOYMENT_ID")
          done

          TRIGGERED=${#POLL_REPOS[@]}
          if [ "$TRIGGERED" -eq 0 ]; then
            echo ""
            echo "No gated repos in deploy plan — ungated repos deploy via tag push."
            exit 0
          fi

          echo ""
          echo "Triggered $TRIGGERED gated repo(s). Polling for completion..."
          echo ""

          # Poll all pipelines in a unified loop (every 20s, up to 10 min)
          MAX_ATTEMPTS=30
          SLEEP_SECONDS=20
          declare -A FINISHED=()

          for attempt in $(seq 1 $MAX_ATTEMPTS); do
            ALL_DONE=true

            for i in "${!POLL_REPOS[@]}"; do
              REPO="${POLL_REPOS[$i]}"

              # Skip already-finished pipelines
              if [ -n "${FINISHED[$REPO]:-}" ]; then
                continue
              fi

              PID="${POLL_PIPELINE_IDS[$i]}"
              DID="${POLL_DEPLOYMENT_IDS[$i]}"
              PIPELINE_NUM=$(jq -r '.number' /tmp/cci_${REPO}.json)

              WF_RESPONSE=$(curl -s \
                "https://circleci.com/api/v2/pipeline/${PID}/workflow" \
                -H "Circle-Token: ${CIRCLECI_TOKEN}")

              STATUS=$(echo "$WF_RESPONSE" | jq -r '.items[0].status // "pending"')
              TARGET_URL="https://app.circleci.com/pipelines/github/Quoyi-ChronoTracer/${REPO}/${PIPELINE_NUM}"

              case "$STATUS" in
                success)
                  echo "[DONE] $REPO — success"
                  curl -s -X POST \
                    "https://api.github.com/repos/Quoyi-ChronoTracer/${REPO}/deployments/${DID}/statuses" \
                    -H "Authorization: token ${GH_TOKEN}" \
                    -H "Accept: application/vnd.github+json" \
                    -d "$(jq -n --arg url "$TARGET_URL" '{
                      state: "success",
                      target_url: $url,
                      description: "Deployment succeeded"
                    }')" > /dev/null
                  FINISHED[$REPO]="success"
                  ;;
                failed|error|canceled)
                  echo "[FAIL] $REPO — $STATUS"
                  curl -s -X POST \
                    "https://api.github.com/repos/Quoyi-ChronoTracer/${REPO}/deployments/${DID}/statuses" \
                    -H "Authorization: token ${GH_TOKEN}" \
                    -H "Accept: application/vnd.github+json" \
                    -d "$(jq -n --arg url "$TARGET_URL" --arg status "$STATUS" '{
                      state: "failure",
                      target_url: $url,
                      description: ("Deployment " + $status)
                    }')" > /dev/null
                  FINISHED[$REPO]="$STATUS"
                  ;;
                *)
                  ALL_DONE=false
                  ;;
              esac
            done

            if [ "$ALL_DONE" = true ]; then
              break
            fi

            if [ "$attempt" -lt "$MAX_ATTEMPTS" ]; then
              echo "[POLL $attempt/$MAX_ATTEMPTS] Waiting ${SLEEP_SECONDS}s..."
              sleep $SLEEP_SECONDS
            fi
          done

          # Handle timeouts
          HAS_FAILURE=false
          for i in "${!POLL_REPOS[@]}"; do
            REPO="${POLL_REPOS[$i]}"
            DID="${POLL_DEPLOYMENT_IDS[$i]}"
            PIPELINE_NUM=$(jq -r '.number' /tmp/cci_${REPO}.json)

            if [ -z "${FINISHED[$REPO]:-}" ]; then
              echo "[TIMEOUT] $REPO — still running after $((MAX_ATTEMPTS * SLEEP_SECONDS))s"
              curl -s -X POST \
                "https://api.github.com/repos/Quoyi-ChronoTracer/${REPO}/deployments/${DID}/statuses" \
                -H "Authorization: token ${GH_TOKEN}" \
                -H "Accept: application/vnd.github+json" \
                -d "$(jq -n --arg url "https://app.circleci.com/pipelines/github/Quoyi-ChronoTracer/${REPO}/${PIPELINE_NUM}" '{
                  state: "in_progress",
                  target_url: $url,
                  description: "Polling timed out — check CircleCI for final status"
                }')" > /dev/null
            elif [ "${FINISHED[$REPO]}" != "success" ]; then
              HAS_FAILURE=true
            fi
          done

          echo ""
          echo "========================================"
          echo "Deployment status summary:"
          for i in "${!POLL_REPOS[@]}"; do
            REPO="${POLL_REPOS[$i]}"
            STATUS="${FINISHED[$REPO]:-timeout}"
            echo "  - $REPO: $STATUS"
          done
          echo "========================================"

          if [ "$HAS_FAILURE" = true ]; then
            echo "::error::One or more deployments failed"
            exit 1
          fi
