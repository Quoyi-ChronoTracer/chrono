name: Deploy Staging

on:
  repository_dispatch:
    types: [staging-deploy]

concurrency:
  group: staging-deploy-${{ github.event.client_payload.repo }}
  cancel-in-progress: false

jobs:
  trigger-circleci:
    runs-on: ubuntu-latest
    environment: deploy-bot
    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@d72941d797fd3113feb6b93fd0dec494b13a2547  # v1.12.0
        with:
          app-id: ${{ secrets.DEPLOY_APP_ID }}
          private-key: ${{ secrets.DEPLOY_APP_PRIVATE_KEY }}
          owner: Quoyi-ChronoTracer
          repositories: chrono-devops,chrono-api,chrono-pipeline-v2,chrono-app,chrono-filter-ai-api

      - name: Mask token
        run: echo "::add-mask::${{ steps.app-token.outputs.token }}"

      - name: Trigger CircleCI pipelines in dependency order
        env:
          CIRCLECI_TOKEN: ${{ secrets.CIRCLECI_API_TOKEN }}
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          DEPLOY_ENV: staging
          SOURCE_REPO: ${{ github.event.client_payload.repo }}
          SOURCE_REF: ${{ github.event.client_payload.ref }}
        run: |
          # --- Dependency graph ---
          # Tier 0: chrono-devops (infra)        — downstream: all
          # Tier 1: chrono-api (backend)          — downstream: tier 2
          # Tier 2: chrono-pipeline-v2, chrono-app, chrono-filter-ai-api (edge) — leaf nodes
          #
          # Deploy the source repo + everything downstream of it.
          # Source repo uses the tag from the dispatch payload.
          # Downstream repos use their latest RC tag (looked up via GitHub API).

          echo "Source repo: ${SOURCE_REPO}"
          echo "Source ref: ${SOURCE_REF}"

          TAG_PATTERN='^v[0-9]+\.[0-9]+\.[0-9]+-rc\.[0-9]+$'

          case "$SOURCE_REPO" in
            chrono-devops)
              TIER_0=("chrono-devops")
              TIER_1=("chrono-api")
              TIER_2=("chrono-pipeline-v2" "chrono-app" "chrono-filter-ai-api")
              ;;
            chrono-api)
              TIER_0=()
              TIER_1=("chrono-api")
              TIER_2=("chrono-pipeline-v2" "chrono-app" "chrono-filter-ai-api")
              ;;
            chrono-pipeline-v2|chrono-app|chrono-filter-ai-api)
              TIER_0=()
              TIER_1=()
              TIER_2=("$SOURCE_REPO")
              ;;
            *)
              echo "::error::Unknown source repo: ${SOURCE_REPO}"
              exit 1
              ;;
          esac

          # --- Helper: look up latest RC tag for a repo ---
          lookup_latest_rc_tag() {
            local repo="$1"

            LATEST_TAG=$(curl -s -H "Authorization: token ${GH_TOKEN}" \
              "https://api.github.com/repos/Quoyi-ChronoTracer/${repo}/git/matching-refs/tags/v" | \
              jq -r '.[].ref' | sed 's|refs/tags/||' | \
              grep -E "$TAG_PATTERN" | sort -V | tail -1)

            if [ -z "$LATEST_TAG" ]; then
              echo "::error::No RC tag found for ${repo} — cannot cascade to staging"
              return 1
            fi

            echo "$LATEST_TAG"
          }

          # --- Helper: trigger a repo and create GitHub Deployment ---
          trigger_repo() {
            local repo="$1"
            local tag="$2"

            echo "[TRIGGER] $repo @ $tag"

            HTTP_CODE=$(curl -s -o /tmp/cci_${repo}.json -w "%{http_code}" \
              -X POST "https://circleci.com/api/v2/project/gh/Quoyi-ChronoTracer/${repo}/pipeline" \
              -H "Circle-Token: ${CIRCLECI_TOKEN}" \
              -H "Content-Type: application/json" \
              -d "{\"tag\": \"${tag}\", \"parameters\": {\"trigger_deploy\": true}}")

            if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
              echo "::error::Failed to trigger CircleCI for $repo (HTTP $HTTP_CODE)"
              cat /tmp/cci_${repo}.json
              return 1
            fi

            local pipeline_id=$(jq -r '.id' /tmp/cci_${repo}.json)
            local pipeline_num=$(jq -r '.number' /tmp/cci_${repo}.json)
            echo "[OK] $repo — CircleCI pipeline $pipeline_id triggered"

            # Create GitHub Deployment
            local deploy_response=$(curl -s -X POST \
              "https://api.github.com/repos/Quoyi-ChronoTracer/${repo}/deployments" \
              -H "Authorization: token ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -d "$(jq -n --arg ref "$tag" --arg env "$DEPLOY_ENV" '{
                ref: $ref,
                environment: $env,
                auto_merge: false,
                required_contexts: [],
                description: "Deployment via staging deploy cascade"
              }')")

            local deployment_id=$(echo "$deploy_response" | jq -r '.id')
            echo "[DEPLOY] $repo — GitHub deployment $deployment_id created"

            # Set initial status
            curl -s -X POST \
              "https://api.github.com/repos/Quoyi-ChronoTracer/${repo}/deployments/${deployment_id}/statuses" \
              -H "Authorization: token ${GH_TOKEN}" \
              -H "Accept: application/vnd.github+json" \
              -d "$(jq -n --arg url "https://app.circleci.com/pipelines/github/Quoyi-ChronoTracer/${repo}/${pipeline_num}" '{
                state: "in_progress",
                target_url: $url,
                description: "CircleCI pipeline running"
              }')" > /dev/null

            # Store IDs for polling
            echo "${pipeline_id}:${deployment_id}:${pipeline_num}" > /tmp/tier_${repo}.txt
          }

          # --- Helper: poll a tier until all pipelines finish (30 min max) ---
          poll_tier() {
            local tier_name="$1"
            shift
            local repos=("$@")

            if [ ${#repos[@]} -eq 0 ]; then
              return 0
            fi

            echo ""
            echo "Polling $tier_name (${repos[*]})..."

            local max_attempts=60
            local sleep_seconds=30
            declare -A finished=()

            for attempt in $(seq 1 $max_attempts); do
              local all_done=true

              for repo in "${repos[@]}"; do
                if [ -n "${finished[$repo]:-}" ]; then
                  continue
                fi

                IFS=':' read -r pid did pnum < /tmp/tier_${repo}.txt
                local target_url="https://app.circleci.com/pipelines/github/Quoyi-ChronoTracer/${repo}/${pnum}"

                local wf_response=$(curl -s \
                  "https://circleci.com/api/v2/pipeline/${pid}/workflow" \
                  -H "Circle-Token: ${CIRCLECI_TOKEN}")

                local status=$(echo "$wf_response" | jq -r '.items[0].status // "pending"')

                case "$status" in
                  success)
                    echo "[DONE] $repo — success"
                    curl -s -X POST \
                      "https://api.github.com/repos/Quoyi-ChronoTracer/${repo}/deployments/${did}/statuses" \
                      -H "Authorization: token ${GH_TOKEN}" \
                      -H "Accept: application/vnd.github+json" \
                      -d "$(jq -n --arg url "$target_url" '{
                        state: "success",
                        target_url: $url,
                        description: "Deployment succeeded"
                      }')" > /dev/null
                    finished[$repo]="success"
                    ;;
                  failed|error|canceled)
                    echo "[FAIL] $repo — $status"
                    curl -s -X POST \
                      "https://api.github.com/repos/Quoyi-ChronoTracer/${repo}/deployments/${did}/statuses" \
                      -H "Authorization: token ${GH_TOKEN}" \
                      -H "Accept: application/vnd.github+json" \
                      -d "$(jq -n --arg url "$target_url" --arg status "$status" '{
                        state: "failure",
                        target_url: $url,
                        description: ("Deployment " + $status)
                      }')" > /dev/null
                    finished[$repo]="$status"
                    ;;
                  *)
                    all_done=false
                    ;;
                esac
              done

              if [ "$all_done" = true ]; then
                break
              fi

              if [ "$attempt" -lt "$max_attempts" ]; then
                echo "[POLL $attempt/$max_attempts] Waiting ${sleep_seconds}s..."
                sleep $sleep_seconds
              fi
            done

            # Check results
            local tier_ok=true
            for repo in "${repos[@]}"; do
              local result="${finished[$repo]:-}"
              if [ -z "$result" ]; then
                echo "[TIMEOUT] $repo — still running after 30m"
                IFS=':' read -r pid did pnum < /tmp/tier_${repo}.txt
                curl -s -X POST \
                  "https://api.github.com/repos/Quoyi-ChronoTracer/${repo}/deployments/${did}/statuses" \
                  -H "Authorization: token ${GH_TOKEN}" \
                  -H "Accept: application/vnd.github+json" \
                  -d "$(jq -n --arg url "https://app.circleci.com/pipelines/github/Quoyi-ChronoTracer/${repo}/${pnum}" '{
                    state: "in_progress",
                    target_url: $url,
                    description: "Polling timed out — check CircleCI for final status"
                  }')" > /dev/null
                tier_ok=false
              elif [ "$result" != "success" ]; then
                tier_ok=false
              fi
            done

            if [ "$tier_ok" = true ]; then
              return 0
            else
              return 1
            fi
          }

          # --- Main: process tiers in dependency order ---
          ALL_TRIGGERED=()

          for tier_idx in 0 1 2; do
            case $tier_idx in
              0) tier_repos=("${TIER_0[@]+"${TIER_0[@]}"}"); tier_label="Tier 0 (infra)" ;;
              1) tier_repos=("${TIER_1[@]+"${TIER_1[@]}"}"); tier_label="Tier 1 (backend)" ;;
              2) tier_repos=("${TIER_2[@]+"${TIER_2[@]}"}"); tier_label="Tier 2 (edge)" ;;
            esac

            if [ ${#tier_repos[@]} -eq 0 ]; then
              echo ""
              echo "[SKIP] $tier_label — not in deploy scope for ${SOURCE_REPO}"
              continue
            fi

            echo ""
            echo "========================================"
            echo "$tier_label: ${tier_repos[*]}"
            echo "========================================"

            # Trigger all repos in this tier
            for repo in "${tier_repos[@]}"; do
              if [ "$repo" = "$SOURCE_REPO" ]; then
                # Source repo: use the tag from the dispatch payload
                TAG="$SOURCE_REF"
              else
                # Downstream repo: look up latest RC tag
                TAG=$(lookup_latest_rc_tag "$repo") || exit 1
              fi

              trigger_repo "$repo" "$TAG" || exit 1
              ALL_TRIGGERED+=("$repo")
            done

            # Poll until tier completes
            if ! poll_tier "$tier_label" "${tier_repos[@]}"; then
              echo ""
              echo "::error::$tier_label failed — aborting downstream tiers"
              echo ""
              echo "========================================"
              echo "Deployment summary:"
              for repo in "${ALL_TRIGGERED[@]}"; do
                if [ -f /tmp/tier_${repo}.txt ]; then
                  echo "  - $repo: check CircleCI"
                fi
              done
              echo "========================================"
              exit 1
            fi
          done

          echo ""
          echo "========================================"
          echo "All tiers completed successfully."
          echo "Deployed repos:"
          for repo in "${ALL_TRIGGERED[@]}"; do
            echo "  - $repo"
          done
          echo "========================================"
