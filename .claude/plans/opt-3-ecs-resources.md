# OPT-3: ECS Task Resource Increase

## Current State

ECS task defined in `chrono-devops/services/ecs.tf` lines 156-202, resource `aws_ecs_task_definition.pipeline_task_definition`.

```hcl
cpu    = 2048   # 2 vCPU
memory = 4096   # 4 GB
```

This configuration is copied verbatim to all accounts via `scripts/create_templates.py` (not a Jinja template -- direct copy).

---

## Proposed Configuration

```hcl
cpu    = 4096   # 4 vCPU
memory = 8192   # 8 GB
```

This is a valid Fargate CPU/memory combination per AWS documentation.

---

## Reasoning

### CPU

Tesseract is CPU-bound. Each OCR call consumes a full core for its duration. More cores enable OPT-4 (parallel OCR workers) to run multiple Tesseract processes simultaneously without contention.

### Memory

8192 MB is the minimum memory for the 4096 CPU tier on Fargate. This also provides headroom to prevent memory pressure degradation -- current tasks occasionally approach 4 GB limits during large document processing, causing swap-like behavior and slowdowns.

---

## Cost Analysis

| Metric | Current (2 vCPU / 4 GB) | Proposed (4 vCPU / 8 GB) |
|---|---|---|
| Per-task-hour cost | $0.0988/hr | $0.1975/hr |
| Typical task duration | ~9 hr | ~6.75 hr (standalone) |
| Per-task cost (standalone) | $0.889 | $1.334 |
| **Standalone cost change** | -- | **+50%** |

### With OPT-4 (Parallel OCR)

| Metric | Proposed + OPT-4 |
|---|---|
| Typical task duration | ~3.5 hr |
| Per-task cost | $0.691 |
| **Cost change vs. current** | **-22%** |

The resource increase alone costs more per task, but combined with OPT-4's parallelism, total cost per task decreases by approximately 22%.

---

## Rollout Plan

### Step 1: Modify `services/ecs.tf`

Change lines 160-161:

```hcl
# Before
cpu    = 2048
memory = 4096

# After
cpu    = 4096
memory = 8192
```

### Step 2: Run `create_templates.py`

```bash
python scripts/create_templates.py
```

This propagates the change to all account-specific output files.

### Step 3: Deploy per account

Deploy in order with validation between each:

1. **develop** -- terraform plan + apply, run test batch
2. **staging** -- terraform plan + apply, run regression suite
3. **prod** -- terraform plan + apply, monitor first batch

```bash
terraform plan -target=aws_ecs_task_definition.pipeline_task_definition
terraform apply -target=aws_ecs_task_definition.pipeline_task_definition
```

---

## Step Functions Timeout

No Step Functions timeout is currently configured -- tasks run until completion. This is unchanged by the resource increase.

**Optional:** Add a 43200-second (12-hour) safety timeout to prevent runaway tasks from consuming resources indefinitely. This is a separate concern but worth noting.

---

## CloudWatch Alarms

Existing CloudWatch alarms at 90% CPU and memory utilization are percentage-based and remain valid after the resource change. The absolute thresholds shift:

| Alarm | Current 90% | Proposed 90% |
|---|---|---|
| CPU | 1843 CPU units | 3686 CPU units |
| Memory | 3686 MB | 7372 MB |

No alarm configuration changes needed.

---

## File Changes Summary

| # | File | Change |
|---|---|---|
| 1 | `chrono-devops/services/ecs.tf` | Lines 160-161: `cpu=2048->4096`, `memory=4096->8192` |
| 2 | Account template outputs | Generated by `scripts/create_templates.py` (no manual edits) |

---

## Rollback Plan

### Standard Rollback

1. Revert `ecs.tf` changes
2. Re-run `create_templates.py`
3. `terraform apply` per account

### Emergency Rollback

1. Register the old task definition revision via AWS CLI:
   ```bash
   aws ecs register-task-definition --cli-input-json file://old-task-def.json
   ```
2. Update the Step Functions state machine to reference the old revision
3. Follow up with terraform state reconciliation
